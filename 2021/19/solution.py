#!/usr/bin/env pypy3

from collections import Counter
from collections import defaultdict
from itertools import combinations

# generated by `generate_rotations.py`
ROTATIONS = [
    [(0, 1), (1, 1), (2, 1)],
    [(1, -1), (0, 1), (2, 1)],
    [(0, -1), (1, -1), (2, 1)],
    [(1, 1), (0, -1), (2, 1)],
    [(2, 1), (1, 1), (0, -1)],
    [(1, -1), (2, 1), (0, -1)],
    [(2, -1), (1, -1), (0, -1)],
    [(1, 1), (2, -1), (0, -1)],
    [(0, -1), (1, 1), (2, -1)],
    [(1, -1), (0, -1), (2, -1)],
    [(0, 1), (1, -1), (2, -1)],
    [(1, 1), (0, 1), (2, -1)],
    [(2, -1), (1, 1), (0, 1)],
    [(1, -1), (2, -1), (0, 1)],
    [(2, 1), (1, -1), (0, 1)],
    [(1, 1), (2, 1), (0, 1)],
    [(0, 1), (2, -1), (1, 1)],
    [(2, 1), (0, 1), (1, 1)],
    [(0, -1), (2, 1), (1, 1)],
    [(2, -1), (0, -1), (1, 1)],
    [(0, -1), (2, -1), (1, -1)],
    [(2, 1), (0, -1), (1, -1)],
    [(0, 1), (2, 1), (1, -1)],
    [(2, -1), (0, 1), (1, -1)],
]

assert len(ROTATIONS) == 24


def rotate(points, rotation):
    for point in points:
        yield tuple(point[coord] * sign for coord, sign in rotation)


def translate(points, translation):
    for point in points:
        yield tuple(a + b for a, b in zip(point, translation))


def parse_scanner(block):
    return [
        tuple(int(s) for s in line.split(","))
        for line in block.splitlines()[1:]
    ]


def read_from_file(filename):
    with open(filename) as file:
        return [parse_scanner(block.strip()) for block in file.read().split("\n\n")]


def find_relative_scanner_orientations(scanners):
    for rotation in ROTATIONS:
        for j, scanner_2 in enumerate(scanners):
            rotated_scanner_2 = list(rotate(scanner_2, rotation))
            for i, scanner_1 in enumerate(scanners):
                if i == j:
                    continue
                for translation, overlap in Counter([
                    # hashing tuples is (relatively) slow in PyPy, so we pack
                    # the three coordinates into a single integer
                    (100_000 + x - X) * 200_000 ** 2
                        + (100_000 + y - Y) * 200_000
                        + (100_000 + z - Z)
                    for X, Y, Z in rotated_scanner_2
                    for x, y, z in scanner_1
                ]).items():
                    if overlap >= 12:
                        translation, c = divmod(translation, 200_000)
                        translation, b = divmod(translation, 200_000)
                        translation, a = divmod(translation, 200_000)
                        assert translation == 0, translation
                        yield i, j, rotation, (a - 100_000, b - 100_000, c - 100_000)


def find_beacon_positions(scanners, seen, relative_scanner_orientations, start):
    all_beacons = set(scanners[start])
    for j, (rotation, translation) in relative_scanner_orientations[start].items():
        if j not in seen:
            seen.add(j)
            new_points = find_beacon_positions(scanners, seen, relative_scanner_orientations, j)
            new_points = rotate(new_points, rotation)
            new_points = translate(new_points, translation)
            all_beacons.update(new_points)
    return all_beacons


def find_scanner_positions(scanners, seen, relative_scanner_orientations, start):
    scanner_positions = [(0, 0, 0)]
    for j, (rotation, translation) in relative_scanner_orientations[start].items():
        if j not in seen:
            seen.add(j)
            new_positions = find_scanner_positions(
                scanners,
                seen,
                relative_scanner_orientations,
                j,
            )
            new_positions = rotate(new_positions, rotation)
            new_positions = translate(new_positions, translation)
            scanner_positions.extend(new_positions)
    return scanner_positions


def distance(p1, p2):
    return sum(abs(x1 - x2) for x1, x2 in zip(p1, p2, strict=True))


def main():
    scanners = read_from_file("input")
    relative_scanner_orientations = defaultdict(dict)
    for i, j, rotation, translation in find_relative_scanner_orientations(scanners):
        relative_scanner_orientations[i][j] = rotation, translation

    assert len(relative_scanner_orientations) == len(scanners)
    all_beacons = find_beacon_positions(scanners, {0}, relative_scanner_orientations, 0)
    print(len(all_beacons))
    scanner_positions = find_scanner_positions(scanners, {0}, relative_scanner_orientations, 0)
    print(max(distance(x, y) for x, y in combinations(scanner_positions, r=2)))


if __name__ == "__main__":
    main()
